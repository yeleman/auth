The auth app provides an interface for creating, updating,
and deleting RapidSMS contacts as rapidsms.contrib.registration does, but
allowing i18n for keywords and some special anwsers if the contact already
exists. It tries to provide some permissions management features as well,
following django.contrib.auth but adding the notion of 'role'.

The code is based on the one from rapidsms.contrib.registration and hence
share the same licence.

Features
=========

    - Ability to anwser in the same language than the keyword
    - Change name if the contact exists but the name is different
    - Tell the contact if he is already registered
    - The contact form includes an identity and a backend field
    - Set the contact language according to the keyword lang when registering
    - When you change the language, the answer is already in the new language

Depends on handlers_i18n, features and limitations apply.

Requirements
============

    - Django 1.2+
    - RapidSMS 1+ 
    - handlers_i18n (http://github.com/yeleman/handlers_i18n)
    - code_generator: http://github.com/yeleman/code_generator

Setup
=====

    - Install handlers_i18n (http://github.com/yeleman/handlers_i18n)
    - Put registration_ng dir somewhere in the Python PATH
    - Add 'registration_ng' to your INSTALLED_APPS
    - Removes 'rapidsms.contrib.registration' from INSTALLED_APPS and RAPIDSMS_TABS
    - Optionnally, add ("register_ng.views.registration", "Registration") to
      RAPIDSMS_TABS
    - Optionally, install 'django_simple_config' (http://github.com/yeleman/django-simple-config)
  
Usage
=====

In SMS::

    >> register Donald Duck 
    << Thank you for registering, Donald Duck!
    >> inscription Tintin
    << Merci de vous être enregistré, Tintin!
    >> lang english
    << I will speak to you in English
    >> register Milou
    << We changed your name from, 'Tintin' to 'Milou' 

/!\ By default, the keyword language always override the contact language
except when switching the language. To change this behavior, set in settings.py::

    RAPIDSMS_REGISTRATION_AUTO_SET_LANG = False
    RAPIDSMS_LANGUAGES_AUTO_SET_LANG = False

You can add your translations in the regular django translation dir.

If you want to add translationa or aliases for keywords, set in settings.py::

    RAPIDSMS_(REGISTRATION|LANGUAGES)_ALIASES = (
                                                    ('language_code1', (alias_1, alias_2)),
                                                    ('language_code2', (alias_1, alias_2)),
                                                 )

E.g::

    RAPIDSMS_LANGUAGES_ALIASES = (
                                    ('en-us', ('lang', 'dialect')),
                                    ('es', ('lingua',)),
                                  )

You can check that a contact is registered using:

- contact.is_registered()
- @registration_required() decorator on your handle() method

Closing registrations
=====================
                                  
If django_simple_config is installed, you will be able to set configuration
values in the Django admin. Set a value 'close_registrations' to the string
"1" (without quotes) to close the registration, and to "0" to reopen them.

Without django_simple_config, the registrations will simply stay always open.

Roles
=====

Roles are the same as group in django.contrib.auth except they apply to a 
contact and have a generic relationship with another model. This allows you
to say "contact x is group z of object w", e.g:

Ben is clinician in Bamako

Basically a role link to a contact, a group and any model. 

To allow some more filtering, auth use RapidSMS extension to add a foreign key
to a user in the contact. The user is autogenerated if you don't provide it. It
will get be added to any group of any role you add to the related contact.

/!\ If you remove a role with group Z and no role with group Z remains for
this contact, the group will be removed from the user. Think about it while
creating your groups.

Basic role usage::

        >>> contact = Contact.objects.create(name='Bob')
        >>> site = Site.objects.create(domain="www.superwebsite.org")
        >>> group = Group.objects.create(name="Webmaster")
        >>> role = Role.objects.create(context, group=group)
        >>> print role
        Webmaster of www.superwebsite.org
        >>> contact.role_set.add(self.role)
        >>> contact.has_role(role)
        'True'
        >>> contact.has_role('r001')
        'True'
        >>> contact.has_role(context=site, group=group)
        'True'
        >>> contact.has_role(group=group) # at least one role with this group
        'True'
        
There are plenty of shortcuts method to check role / contact relationship
in precise and fuzzy ways. Of course, all you can use all the ORM goodness. 
One of the shortcut you may use often is:

@role_required

A decorator that you place on the handle() method to ensure only particular
roles can access to this SMS command.

Each role got an automatically generated code in the form of 'r001' that is
incremented, but you can override it.
        


Documentation
=============

The project is in progress and evolves with our project needs. It's too young
for now to have a complete documentation. However, there is a good amount
of unittest and docstring that we keep up to date and will show you the way
for advanced use.


TODO
=====

Roles contraints
-----------------

    - this role can be added only if you/somebody have this role
    - this role can be added only if you/somebody don't have this role
    - function to check if a role can be added or deleted

Password management
----------------------


    - some SMS like >> pwd blob
                    >> register  name username role rolecode pwd Blob
                    >> register  name username role group context
                    >> register  name username roles rolecode rolecode rolecode 
    
    - if password is sent, it is obfuscated in logger and later messages
    - reponds : "your new password is 'XXX' (obfuscate in logger),
                 remember to delete all sms containg your password in your 
                 inbox AND outbox check that this password is the right one"
    
    - change password
    





TODO
=====

More shortcuts
-----------------

    - More decorators:
      @credentials_require(roles=[], groups[], permission=[]), 
      @one_credential_required(roles=[], groups[], permission=[])
      @forbidden_to_role
      @forbidden_to_group
    - has_credential() method


Roles contraints
-----------------

    - this role can be added only if you/somebody have this role
    - this role can be added only if you/somebody don't have this role
    - function to check if a role can be added or deleted

Password management
----------------------


    - some SMS like >> pwd blob
                    >> register  name username role rolecode pwd Blob
                    >> register  name username role group context
                    >> register  name username roles rolecode rolecode rolecode 
    
    - if password is sent, it is obfuscated in logger and later messages
    - reponds : "your new password is 'XXX' (obfuscate in logger),
                 remember to delete all sms containg your password in your 
                 inbox AND outbox check that this password is the right one"
    
    - change password
    
